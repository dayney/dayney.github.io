import{_ as s,c as i,o as a,V as n}from"./chunks/framework.CthfA3PS.js";const g=JSON.parse('{"title":"在async await中使用finally","description":"","frontmatter":{"outline":"deep","editLink":false},"headers":[],"relativePath":"frontend/javascript/iife.md","filePath":"frontend/javascript/iife.md","lastUpdated":1733479136000}'),t={name:"frontend/javascript/iife.md"},l=n(`<h1 id="在async-await中使用finally" tabindex="-1">在async await中使用finally <a class="header-anchor" href="#在async-await中使用finally" aria-label="Permalink to &quot;在async await中使用finally&quot;">​</a></h1><h2 id="_1-背景" tabindex="-1">1 背景 <a class="header-anchor" href="#_1-背景" aria-label="Permalink to &quot;1 背景&quot;">​</a></h2><p>常规的<strong>IIFE</strong>的结构是**(function(xx){})(xx)<strong>。这样的格式，这次是在看</strong>vant<strong>的源码的时候发现，前面先传了一个</strong>0**。平时用的少，这次就记录下来。</p><h2 id="_2-源码" tabindex="-1">2 源码 <a class="header-anchor" href="#_2-源码" aria-label="Permalink to &quot;2 源码&quot;">​</a></h2><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">obj</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	// xxx</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})(obj)</span></span></code></pre></div><h2 id="_3-特殊性" tabindex="-1">3 特殊性 <a class="header-anchor" href="#_3-特殊性" aria-label="Permalink to &quot;3 特殊性&quot;">​</a></h2><p>​ 1. <strong>逗号运算符</strong>：(0, function(obj){ ... }) 中的 0, function(obj){ ... } 是使用逗号运算符来创建一个表达式。逗号运算符会返回最后一个表达式的值，所以这里实际的结果是 function(obj){ ... }。</p><p>​ 2. <strong>上下文绑定问题</strong>：在一些特定场景中，直接写 function(obj){ ... }({...}) 会将函数的调用绑定到它的定义上下文（可能是全局对象或调用环境）。通过加 (0, ...)，可以显式将函数调用绑定到默认上下文（通常是 undefined，在严格模式下）。</p><h2 id="_4-为什么这样写" tabindex="-1">4 为什么这样写 <a class="header-anchor" href="#_4-为什么这样写" aria-label="Permalink to &quot;4 为什么这样写&quot;">​</a></h2><p>这种写法的核心目的是 <strong>避免意外的上下文绑定</strong>。如果不这样处理，在某些环境中，直接调用匿名函数可能会绑定到不需要的上下文，例如 window 对象或其他意外对象。这种模式保证了调用时不会与外部上下文产生意外的绑定。</p><h2 id="_5-好处" tabindex="-1">5 好处 <a class="header-anchor" href="#_5-好处" aria-label="Permalink to &quot;5 好处&quot;">​</a></h2><ol><li><strong>避免上下文绑定错误：</strong> 确保匿名函数在调用时不会受到定义上下文的影响。</li><li><strong>与严格模式兼容：</strong> 在严格模式下，this 为 undefined，可以避免潜在的错误。</li><li><strong>更清晰的调用方式：</strong> 通过逗号操作符分隔，明确意图，表示“这里的 0 是无关紧要的，只是确保函数调用的上下文正确”。</li></ol><h2 id="_6-应用场景" tabindex="-1">6 应用场景 <a class="header-anchor" href="#_6-应用场景" aria-label="Permalink to &quot;6 应用场景&quot;">​</a></h2><ol><li><p><strong>模块化代码加载</strong></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})({</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;模块初始化&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div></li><li><p>**浏览器兼容性代码：**在一些低版本浏览器（如早期 IE）中，直接调用匿名函数可能出现意外的上下文绑定。</p></li><li><p>**防止污染全局环境：**当匿名函数内部逻辑复杂且上下文敏感时，用这种写法确保安全性。</p></li></ol><h2 id="_7-总结" tabindex="-1">7 总结 <a class="header-anchor" href="#_7-总结" aria-label="Permalink to &quot;7 总结&quot;">​</a></h2><p>通过 (0, function(){...})({...}) 这种模式，我们可以：</p><p>• 确保函数调用不受上下文绑定的干扰。</p><p>• 避免潜在的 this 绑定问题。</p><p>• 适用于模块初始化、浏览器兼容等场景。</p>`,19),e=[l];function h(p,r,o,k,d,c){return a(),i("div",null,e)}const y=s(t,[["render",h]]);export{g as __pageData,y as default};
