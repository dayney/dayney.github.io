import{_ as t,c as o,o as r,V as e}from"./chunks/framework.CsbsVE7l.js";const s="/assets/code_post_request.BNrKc__Y.png",n="/assets/browser_get_request.C5ByStOm.png",a="/assets/http_redirect_flow_diagram_v3_zh.5zUSxoys.png",d="/assets/solution_code_fix.N3YEqEyC.png",S=JSON.parse('{"title":"登录失败深度解析：POST 请求为何变成了 GET？","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/scene/redirct-url.md","filePath":"frontend/scene/redirct-url.md","lastUpdated":1768196439000}'),i={name:"frontend/scene/redirct-url.md"},l=e('<h1 id="登录失败深度解析-post-请求为何变成了-get" tabindex="-1">登录失败深度解析：POST 请求为何变成了 GET？ <a class="header-anchor" href="#登录失败深度解析-post-请求为何变成了-get" aria-label="Permalink to &quot;登录失败深度解析：POST 请求为何变成了 GET？&quot;">​</a></h1><h2 id="⚠️-一句话总结" tabindex="-1">⚠️ 一句话总结 <a class="header-anchor" href="#⚠️-一句话总结" aria-label="Permalink to &quot;⚠️ 一句话总结&quot;">​</a></h2><p>我们在代码里写的是 <code>POST</code> 请求，但因为请求地址写的是 <code>http</code>，服务器为了安全返回了 <strong>301/302 重定向</strong> 要求跳转到 <code>https</code>。浏览器在处理这种重定向时，出于安全规范，会自动将 <code>POST</code> 请求降级为 <strong>GET</strong> 请求，并丢弃请求体（密码等数据），从而导致登录失败。</p><hr><h2 id="_1-案发现场-代码与现实的冲突" tabindex="-1">1. 案发现场：代码与现实的冲突 <a class="header-anchor" href="#_1-案发现场-代码与现实的冲突" aria-label="Permalink to &quot;1. 案发现场：代码与现实的冲突&quot;">​</a></h2><ul><li><p><strong>前端代码</strong>：明确指定使用 <code>post</code> 方法提交账号密码。 <img src="'+s+'" alt="代码截图"></p></li><li><p><strong>浏览器抓包</strong>：却发现发出去的是 <code>GET</code> 请求，且参数全部丢失。 <img src="'+n+'" alt="浏览器抓包"></p></li></ul><hr><h2 id="_2-幕后黑手-http-重定向-301-302" tabindex="-1">2. 幕后黑手：HTTP 重定向 (301/302) <a class="header-anchor" href="#_2-幕后黑手-http-重定向-301-302" aria-label="Permalink to &quot;2. 幕后黑手：HTTP 重定向 (301/302)&quot;">​</a></h2><p>这<strong>不是</strong>浏览器的 Bug，而是 HTTP 协议定义的一种安全机制。</p><p>我们需要了解两个关键的 HTTP 状态码：</p><ul><li><strong>301 (Moved Permanently)</strong>: 永久重定向。表示“原本的地址已经作废，以后请直接去新地址”。</li><li><strong>302 (Found)</strong>: 临时重定向。表示“原本的地址暂时不能用，请临时去新地址看看”。</li></ul><p><strong>🔴 关键规则</strong> 当浏览器发起非 GET 请求（如 <code>POST</code>）并收到 301 或 302 响应时，绝大多数浏览器（及其规范）会采取“安全优先”的策略：</p><ol><li><strong>改变方法</strong>：将 <code>POST</code> 改为 <code>GET</code>。</li><li><strong>丢弃数据</strong>：丢弃原始请求体中的敏感数据（如密码），防止数据在跳转过程中被意外泄露或重复提交。</li></ol><hr><h2 id="_3-还原真相-请求是如何-变异-的" tabindex="-1">3. 还原真相：请求是如何“变异”的 <a class="header-anchor" href="#_3-还原真相-请求是如何-变异-的" aria-label="Permalink to &quot;3. 还原真相：请求是如何“变异”的&quot;">​</a></h2><p><img src="'+a+'" alt="请求重定向深度解析图 (v3版)"></p><p><strong>步骤深度解析：</strong></p><ol><li><strong>错误的起点</strong>：我们在代码中配置了 <code>http://</code> 目标地址，导致浏览器向服务器的 <strong>80端口 (HTTP)</strong> 发起了 <code>POST</code> 请求（携带了账号密码）。</li><li><strong>传达室的拦截</strong>：服务器的 HTTP 服务虽然开启了，但它被配置为**“仅负责重定向，不处理业务”**。它看到你来访问 HTTP，直接拦截并返回 <strong>301/302 状态码</strong>，意思是：“我不办业务，请从这出门，去隔壁的 HTTPS (443端口) 大厅”。</li><li><strong>浏览器的自我阉割 (关键)</strong>：浏览器收到了“去新地址”的指令。但在跳转时，为了防止你的敏感数据（POST Body 中的账号密码）被发送到未知的第三方或泄露，浏览器触发了<strong>安全保护机制</strong>——<strong>它不仅把 HTTP 改成了 HTTPS，还顺手把 POST 方法降级成了 GET 方法，并丢弃了所有 Body 数据</strong>。</li><li><strong>无辜的终点</strong>：最终，请求到达了正确的 HTTPS (443端口) 服务，但此时它已经变成了一个<strong>空空如也的 GET 请求</strong>。服务器一脸懵圈：“你要登录？你的账号密码呢？”，只能报错。</li></ol><hr><h2 id="_4-终极解决方案" tabindex="-1">4. 终极解决方案 <a class="header-anchor" href="#_4-终极解决方案" aria-label="Permalink to &quot;4. 终极解决方案&quot;">​</a></h2><p>既然问题出在“绕路”上，解决方案就是<strong>不绕路</strong>。</p><p>直接在配置文件中，将 API 地址的协议从 <code>//</code> (自动适配) 或 <code>http://</code> 改为明确的 <strong><code>https://</code></strong>。</p><p><img src="'+d+'" alt="代码修复"></p><p>这样前端直接向 HTTPS 地址发起 POST 请求，服务器直接接收，不再触发重定向，问题完美解决。</p><hr><h2 id="_5-扩展知识-如何保留-post-状态" tabindex="-1">5. 扩展知识：如何保留 POST 状态？ <a class="header-anchor" href="#_5-扩展知识-如何保留-post-状态" aria-label="Permalink to &quot;5. 扩展知识：如何保留 POST 状态？&quot;">​</a></h2><p>如果确实需要重定向且必须保留 POST 方法（例如支付回调），服务器应该使用以下状态码：</p><ul><li><strong>307 (Temporary Redirect)</strong>: 类似 302，但强制要求浏览器<strong>不改变</strong>请求方法和 Body。</li><li><strong>308 (Permanent Redirect)</strong>: 类似 301，但也强制<strong>保持</strong>原有的 POST 方法和 Body。</li></ul><p>但在本案例中，直接配置正确的 HTTPS 地址才是最标准、最高效的做法。</p>',29),c=[l];function g(p,_,T,h,P,u){return r(),o("div",null,c)}const f=t(i,[["render",g]]);export{S as __pageData,f as default};
