import{_ as e,c as t,o as p,V as o}from"./chunks/framework.CsbsVE7l.js";const _=JSON.parse('{"title":"","description":"","frontmatter":{"outline":"deep","editLink":false},"headers":[],"relativePath":"books/High_Performance/chapter4.md","filePath":"books/High_Performance/chapter4.md","lastUpdated":1705669135000}'),a={name:"books/High_Performance/chapter4.md"},l=o('<h3 id="需要加强的" tabindex="-1">需要加强的 <a class="header-anchor" href="#需要加强的" aria-label="Permalink to &quot;需要加强的&quot;">​</a></h3><p>[ ] 1. document.createTextNode()</p><p>[ ] 2. element.clone()</p><p>[ ] 3. HTML集合:常用的document.querySelector(); document.querySelectorAll();</p><p>3.1 document.getElementsByName()</p><p>3.2 document.getsByClassName()</p><p>3.3 document.getElementsByTagName()</p><p>3.4 document.images</p><p>3.5 document.links</p><p>3.6 document.forms</p><p>3.5 document.forms[0].elements</p><p>[ ] 4. node 相关</p><p>4.1 nodeName</p><p>4.2 nodeType</p><p>4.3 tagName（非node，但）</p><p>[ ] 5. tagName</p><p>[ ] 6. 获取DOM元素，用<code>jquery</code>比较多，有相似的地方</p><p>6.1 childNodes</p><p>6.2 nextSibling</p><p>6.3 firstNodes</p><p>6.4 lastNodes</p><p>6.5 previousSibling</p><p>6.6 children只有在IE6/7/8中使用</p><p>6.7 className</p><p>6.8 appendChild</p><p>6.9 replaceChild</p><p>[ ] 7. 获取元素的计算属性：</p><p>7.1 getComputedStyle()/currentStyle</p><p>7.2 cssText</p><p>[ ] 8. 文档片段：</p><p>7.1 document.createDocumentFragment()</p><h3 id="爬虫相关" tabindex="-1"><strong>爬虫相关</strong> <a class="header-anchor" href="#爬虫相关" aria-label="Permalink to &quot;**爬虫相关**&quot;">​</a></h3><ol><li>document.images</li><li>document.links</li></ol><p>可以参考使用<code>css3 animation</code>来制作动画，原则：能用css解决的尽量使用css解决；</p><h3 id="制作动画需要谨慎的事" tabindex="-1"><strong>制作动画需要谨慎的事</strong> <a class="header-anchor" href="#制作动画需要谨慎的事" aria-label="Permalink to &quot;**制作动画需要谨慎的事**&quot;">​</a></h3><ol><li>使用绝对位置定位页面上的动画元素，将其脱离文档流；</li><li>让元素动起来。当它扩大时，会临时覆盖部分页面。但这只是页面一个小区域的重绘过程，不会产生重排并重绘页面的大部分内容；</li><li>当动画结束时恢复定位，从而只会下移一次文档的其他元素。</li></ol><h3 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h3><blockquote><ol><li><p>最小化DOM访问次数，尽可能在JavaScript端处理；</p></li><li><p>如果需要多次访问某个DOM节点，请使用局部变量存储它的引用；</p></li><li><p>小心处理HTML集合，因为它实时连接着底层文档。把集合的长度缓存到一个变量中，并在迭代中使用它。如果需要经常操作集合，建议把它拷贝到一个数组中。</p></li><li><p>如果可能的话，使用速度更快的API，比如querySelectorAll和firstElementChild</p></li><li><p>要留意重绘和重排；批量修改样式时，&quot;离线&quot;操作DOM树，使用缓存，并减少访问布局信息的次数；</p></li><li><p>动画中使用绝对定位，使用拖放代理；</p></li><li><p>使用事件委托来减少事件处理器的数量；</p></li></ol></blockquote>',38),i=[l];function n(r,c,s,d,m,u){return p(),t("div",null,i)}const f=e(a,[["render",n]]);export{_ as __pageData,f as default};
