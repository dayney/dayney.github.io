import{_ as t,c as o,o as e,V as s}from"./chunks/framework.CsbsVE7l.js";const k=JSON.parse('{"title":"🚀 让 Cursor 熟悉项目的终极指南","description":"","frontmatter":{"outline":"deep","editLink":false},"headers":[],"relativePath":"efficiency/ai/cursor-guide.md","filePath":"efficiency/ai/cursor-guide.md","lastUpdated":1763431280000}'),r={name:"efficiency/ai/cursor-guide.md"},a=s(`<h1 id="🚀-让-cursor-熟悉项目的终极指南" tabindex="-1">🚀 让 Cursor 熟悉项目的终极指南 <a class="header-anchor" href="#🚀-让-cursor-熟悉项目的终极指南" aria-label="Permalink to &quot;🚀 让 Cursor 熟悉项目的终极指南&quot;">​</a></h1><p>这份指南将引导我们共同完成一个标准化的流程，将一个“黑盒”般的古老项目，转变为一个拥有清晰文档、明确边界、且极度适合人机协作的“白盒”项目。最终目标是在后续的功能迭代中实现<strong>高效、安全、高质量</strong>的开发。</p><h2 id="🗺️-整体流程概览" tabindex="-1">🗺️ 整体流程概览 <a class="header-anchor" href="#🗺️-整体流程概览" aria-label="Permalink to &quot;🗺️ 整体流程概览&quot;">​</a></h2><table><thead><tr><th style="text-align:left;">阶段</th><th style="text-align:left;">核心目标</th><th style="text-align:left;">关键产出</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>❶ 探索与奠基</strong></td><td style="text-align:left;">AI 自动扫描项目，建立知识库雏形</td><td style="text-align:left;"><code>📄 .cursorignore</code>, <code>📂 docs/</code>, <code>📂 .cursor/</code>, <code>🤖 AI 规则与上下文</code>, <code>👨‍💻 人类可读报告</code></td></tr><tr><td style="text-align:left;"><strong>❷ 集成与提效</strong></td><td style="text-align:left;">将 AI 与开发流程深度绑定，提升效率</td><td style="text-align:left;"><code>⚡️ VSCode 快捷指令</code>, <code>📜 标准化协作流程文档</code></td></tr><tr><td style="text-align:left;"><strong>❸ 固化与进化</strong></td><td style="text-align:left;">固化 AI 角色，并建立知识库的自维护机制</td><td style="text-align:left;"><code>🧠 AI 初始化指令</code>, <code>🔄 知识库自维护流程</code></td></tr></tbody></table><hr><h2 id="❶-阶段一-探索与奠基-🧭" tabindex="-1">❶ 阶段一：探索与奠基 🧭 <a class="header-anchor" href="#❶-阶段一-探索与奠基-🧭" aria-label="Permalink to &quot;❶ 阶段一：探索与奠基 🧭&quot;">​</a></h2><p><strong>目的</strong>：通过一个初始指令，让 AI 自动完成对项目的初步扫描，并搭建起整个双轨知识体系的骨架。</p><h3 id="✔️-1-1-智能降噪与目录初始化" tabindex="-1">✔️ 1.1 智能降噪与目录初始化 <a class="header-anchor" href="#✔️-1-1-智能降噪与目录初始化" aria-label="Permalink to &quot;✔️ 1.1 智能降噪与目录初始化&quot;">​</a></h3><p><strong>要做什么：</strong> 通过一个指令，让 AI 自动生成 <code>📄 .cursorignore</code> 文件，并创建 <code>📂 docs/</code> 和 <code>📂 .cursor/</code> 两个核心目录。</p><details><summary>查看原因与指令示例</summary><p><strong>为什么这么做：</strong> 这是所有工作的基础。一个干净的环境能保证 AI 分析的准确性；预设的目录结构为后续自动化生成文档提供了清晰的目标路径。</p><p><strong>自动化指令示例：</strong></p><blockquote><p>“请为本项目执行初始化：</p><ol><li>分析项目结构，生成一份最优的 <code>.cursorignore</code> 文件。</li><li>创建 <code>docs/</code> 和 <code>.cursor/</code> 两个目录。”</li></ol></blockquote></details><h3 id="✔️-1-2-提取项目-dna-并生成双轨文档初稿" tabindex="-1">✔️ 1.2 提取项目 DNA 并生成双轨文档初稿 <a class="header-anchor" href="#✔️-1-2-提取项目-dna-并生成双轨文档初稿" aria-label="Permalink to &quot;✔️ 1.2 提取项目 DNA 并生成双轨文档初稿&quot;">​</a></h3><p><strong>要做什么：</strong> 通过一个集成的指令，让 AI 深度扫描项目，并将分析结果同时转化为<strong>给 AI 的配置文件</strong>和<strong>给人的深度文档</strong>。</p><details><summary>查看原因与指令示例</summary><p><strong>为什么这么做：</strong> 这一步是整个方法论的核心。它将项目的隐性知识一次性、自动化地转化为两套不同形式的显性文档，确保了人与 AI 从一开始就基于同一份“事实”工作，只是阅读的版本不同。</p><p><strong>自动化指令示例：</strong></p><blockquote><p>“请对整个项目（遵循 <code>.cursorignore</code>）进行深度扫描，并基于分析结果完成以下任务：</p><ol><li><strong>生成 AI 规则 (<code>📄 .cursorrules</code>)</strong>：将分析出的技术栈、代码风格和项目约束，生成一份严格的 <code>.cursorrules</code> 文件，存入 <code>.cursor/</code> 目录。</li><li><strong>生成 AI 上下文 (<code>📄 .cursor/context.md</code>)</strong>：将项目的核心模块、全局变量等关键信息，提炼成一份简洁的 Markdown 文件，存入 <code>.cursor/</code>。</li><li><strong>生成人类文档 (<code>📄 docs/01_Project_DNA_Report.md</code>)</strong>：将所有分析的详细结果——包括技术栈、架构模式、代码风格、全局变量、已知技术债等——汇总成一份详尽的报告，存入 <code>docs/</code> 目录，供团队成员阅读。”</li></ol></blockquote></details><hr><h2 id="❷-阶段二-集成与提效-⚙️" tabindex="-1">❷ 阶段二：集成与提效 ⚙️ <a class="header-anchor" href="#❷-阶段二-集成与提效-⚙️" aria-label="Permalink to &quot;❷ 阶段二：集成与提效 ⚙️&quot;">​</a></h2><p><strong>目的</strong>：将 AI 的行为与我们的开发环境和工作流程深度绑定，使其成为一个召之即来、用之顺手的工具。</p><h3 id="✔️-2-1-配置-cursor-快捷指令-⚡️-chat-prompttemplate" tabindex="-1">✔️ 2.1 配置 Cursor 快捷指令 (<code>⚡️ chat.promptTemplate</code>) <a class="header-anchor" href="#✔️-2-1-配置-cursor-快捷指令-⚡️-chat-prompttemplate" aria-label="Permalink to &quot;✔️ 2.1 配置 Cursor 快捷指令 (\`⚡️ chat.promptTemplate\`)&quot;">​</a></h3><p><strong>要做什么：</strong> 在 <code>.vscode/settings.json</code> 中定义一系列快捷指令，将复杂的任务封装成简单的命令。</p><details><summary>查看原因与配置示例</summary><p><strong>为什么这么做：</strong> 这极大地降低了与 AI 协作的门槛。我们不再需要每次都输入冗长的指令，而是可以通过 <code>/analyze</code>、<code>/refactor</code> 等短命令，快速调用 AI 完成标准化任务，提升日常开发效率。</p><p><strong>配置示例 (<code>.vscode/settings.json</code>)：</strong></p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;chat.promptTemplate&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;analyze&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;分析 {{file}} 的架构，参考 @.cursor/context.md 和 @docs/01_Project_DNA_Report.md&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;refactor&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;为 {{file}} 的 {{selectedText}} 函数提供安全重构方案，遵循 @.cursorrules&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;test&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;为 {{file}} 的 {{selectedText}} 函数生成 QUnit 测试用例，注意项目规则&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></details><h3 id="✔️-2-2-定义人机协作工作流" tabindex="-1">✔️ 2.2 定义人机协作工作流 <a class="header-anchor" href="#✔️-2-2-定义人机协作工作流" aria-label="Permalink to &quot;✔️ 2.2 定义人机协作工作流&quot;">​</a></h3><p><strong>要做什么：</strong> 在 <code>docs/</code> 目录中创建一份 <code>📜 02_Collaborative_Workflow.md</code>，明确定义在功能迭代中，人与 AI 如何分工与协作。</p><details><summary>查看原因与工作流示例</summary><p><strong>为什么这么做：</strong> 标准化的流程可以确保每次迭代的质量。它明确了从需求分析到代码审查的每一步中，AI 应该扮演什么角色、我们应该如何向 AI 提问，从而形成一个高效、可预测的开发节奏。</p><p><strong>工作流示例 (<code>docs/02_Collaborative_Workflow.md</code>)：</strong></p><ol><li><strong>需求分析</strong>：开发者向 AI 提问，AI 基于知识库提供实现建议和影响面分析。</li><li><strong>代码实现</strong>：开发者或 AI（在监督下）编写代码，AI 需严格遵守 <code>.cursorrules</code>。</li><li><strong>代码审查</strong>：开发者请求 AI 对新代码进行审查，检查其是否违反项目规则或引入新风险。</li></ol></details><hr><h2 id="❸-阶段三-固化与进化-🧠" tabindex="-1">❸ 阶段三：固化与进化 🧠 <a class="header-anchor" href="#❸-阶段三-固化与进化-🧠" aria-label="Permalink to &quot;❸ 阶段三：固化与进化 🧠&quot;">​</a></h2><p><strong>目的</strong>：通过一个标准化的“唤醒”协议，确保 AI 在任何时候都能快速进入其“遗留项目维护专家”的角色。同时，建立一个让知识库与代码同步更新的机制。</p><h3 id="✔️-3-1-终极初始化协议" tabindex="-1">✔️ 3.1 终极初始化协议 <a class="header-anchor" href="#✔️-3-1-终极初始化协议" aria-label="Permalink to &quot;✔️ 3.1 终极初始化协议&quot;">​</a></h3><p><strong>要做什么：</strong> 在 <code>.cursor/prompts/</code> 目录下创建一个 <code>init.md</code> 文件，作为 AI 的标准启动指令。</p><details><summary>查看原因与指令示例</summary><p><strong>为什么这么做：</strong> 这确保了 AI 的长期一致性。无论何时开启一个新的聊天会话，我们都可以通过这个指令，让 AI 瞬间加载所有必要的上下文和规则，立刻进入最佳工作状态。</p><p><strong>自动化指令示例 (保存于 <code>.cursor/prompts/init.md</code>)</strong>：</p><blockquote><p>“<strong>[系统重置：遗留项目维护模式]</strong></p><p>你是一个专注于维护此项目的 AI 专家。你的所有行为都必须基于 <code>.cursor/</code> 目录下的知识库。</p><p><strong>核心指令：</strong></p><ol><li><strong>读取知识库</strong>：在回答前，必须先 silently review <code>.cursorrules</code> 和 <code>.cursor/context.md</code>。</li><li><strong>必要时查阅详细文档</strong>：如果遇到模糊不清的问题，你有权限查阅 <code>docs/</code> 目录下的相关文档以获取更深层次的理解。</li></ol><p>你的知识库已加载，角色已设定。请回复‘<strong>维护专家已就位，随时待命。</strong>’以确认。”</p></blockquote></details><h3 id="✔️-3-2-ai-驱动的知识库自维护" tabindex="-1">✔️ 3.2 AI 驱动的知识库自维护 <a class="header-anchor" href="#✔️-3-2-ai-驱动的知识库自维护" aria-label="Permalink to &quot;✔️ 3.2 AI 驱动的知识库自维护&quot;">​</a></h3><p><strong>要做什么：</strong> 在代码发生变更后，指示 AI 自动扫描改动，并同步更新 <code>.cursor/</code> 和 <code>docs/</code> 中的相关文档。</p><details><summary>查看原因与指令示例</summary><p><strong>为什么这么做：</strong> 这是解决“文档与代码脱节”这一千古难题的终极方案。通过建立一个自动化的维护流程，我们确保了知识库是一个动态的、与项目共同成长的“活文档”，其价值会随着时间的推移而不断累积。</p><p><strong>自动化指令示例：</strong></p><blockquote><p>“我刚刚完成了 [X功能] 的开发。请扫描相关的 Git diff，并自动更新 <code>.cursor/</code> 和 <code>docs/</code> 目录中所有受影响的文档，确保两套知识库与代码同步。”</p></blockquote></details>`,31),d=[a];function i(n,l,c,p,h,g){return e(),o("div",null,d)}const m=t(r,[["render",i]]);export{k as __pageData,m as default};
